TODO FIX BUGS:
- Empty collection on left-side of primitive throws error even if rigth-side and expectedType are known
- Bad error reporting on primitve type-mismatch

TODO IMPLEMENT:
- Typeclass "Type" Ref:
    1. Ident
    2. Is sealed
    3. Generics
    4. Super typeclass
    5. Function names and signatures
- Allow for partial function application to non-closure functions,
    allows currying on functions with 1 parameter set

Other Notes:
- An adt in a typeclass MUST have implementations of the listed functions with the types defined
- Only 1 typeclass per adt?
- Overloads on derived adt's are implicit and optional
- :> and <: for bounded types only
- Sets in Collection Types
- Lazy Evaluation (need to figure out lazy parameters)
- Polymorphic inference, ex: print[int](5) to print(5). [] is omitted due to inference of parameter type

# Bounding polymorhpic type T to Vehicle subclasses
fn printWheels[T :> Vehicle](v: T) -> null = {
    println(v.wheels)
}

fn makeCar() -> Car = Car(4, 2012)

# bird operator for function chaining
makeCar() |> printWheels()

# Bounded type-list
fn collHead[T :> { List, Array, Tuple, Set }, U](coll: T[U]) -> U = {
    coll.head()
}