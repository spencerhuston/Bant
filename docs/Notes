TODO:
- More type-tagging during parsing phase
- Bird operator
- Modules/Imports

Parser Tests TODO:
- matchStatementEndRequired: bad match
- peek: no match
- parse: IndexOutOfBoundsException
- parseExp: OOB
- parseCollectionValue: Unexpected
- parseCasePattern: Ident as type
- parseValueCase: Ident as value
- parseValueCase: parseLit noOp
- warnAnyCase: wildcard occurs or no wildcard case
- warnAnyCase: wildcard is not last pattern
- parseSuperType
- parseTypeclass
- parseInstance
- parseAdt
- parseRecord
- parseAlias
- parseGenerics: type bounds exist
- parseLambda: no parameters
- parseUtight: unary not or minus
- parseArguments
- parseApplication
- parseTupleAccessIndex
- parseAtom: parentheses enclosed
- parseAtom: tupleAccess
- parseLit: null
- parseLit: string
- parseLit: Unexpected
- parseType: char
- parseType: string
- parseType: null
- parseType: list
- parseType: array
- parseType: set
- parseType: dict
- parseType: tuple
- parseType: parentheses enclosed
- parseType: ident
- parseType: bad type
- reportBadMatch
- reportBadType
- reportUnexpected
- warn

Other Notes:
- An adt in a typeclass MUST have implementations of the listed functions with the types defined
- Only 1 typeclass per adt?
- Overloads on derived adt's are implicit and optional
- :> and <: for bounded types only
- Sets in Collection Types
- Lazy Evaluation (need to figure out lazy parameters)
- Polymorhpic parameter as a part of type syntax
- Polymorphic inference, ex: print[int](5) to print(5). [] is omitted due to inference of parameter type

# Bounding polymorhpic type T to Vehicle subclasses
fn printWheels[T :> Vehicle](v: T) -> null = {
    println(v.wheels)
}

fn makeCar() -> Car = Car(4, 2012)

# bird operator for function chaining
makeCar() |> printWheels()

# Bounded type-list
fn collHead[T :> { List, Array, Tuple, Set }, U](coll: T[U]) -> U = {
    coll.head()
}