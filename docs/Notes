TYPECLASS TODO:
1. ADT derive from typeclass
2. Typeclass superclass
3. Type in multiple typeclasses

ADT TODO:
1. Grammar
2. Supertypes
3. Self-reference
4. Pipe operator for product types
5. Nameless types
6. Records

type Some[T] { T };
type None { };

type Option[T] {
    Some[T] | None
};

type Person {
    int, string | Gender
};

record Person {
    age: int,
    name: string
};

Function Application TODO:
1. Regular calls
2. Curried calls
3. Chained calls with bird operator
4. Calls with generics is optional/polymorphic inference based on arguments
5. Collection access
6. ADT construction

General TODO:
1. More type-tagging during parsing phase
2. Extend Exp into Statement to automatically parse ; and after-exp

Other Notes:
- An adt in a typeclass MUST have implementations of the listed functions with the types defined
- Only 1 typeclass per adt?
- Overloads on derived adt's are implicit and optional
- :> and <: for bounded types only
- Sets in Collection Types
- Lazy Evaluation (need to figure out lazy parameters)
- Polymorhpic parameter as a part of type syntax
- Polymorphic inference, ex: print[int](5) to print(5). [] is omitted due to inference of parameter type

# Bounding polymorhpic type T to Vehicle subclasses
fn printWheels[T :> Vehicle](v: T) -> null = {
    println(v.wheels)
}

fn makeCar() -> Car = Car(4, 2012)

# bird operator for function chaining
makeCar() |> printWheels()

# Bounded type-list
fn collHead[T :> { List, Array, Tuple, Set }, U](coll: T[U]) -> U = {
    coll.head()
}